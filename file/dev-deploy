#!/usr/bin/env python3
# PYTHON_ARGCOMPLETE_OK
#
# If you want to enable tab completion of this script, you must install
# argcomplete, for details, see:
#
# https://kislyuk.github.io/argcomplete/#installation
import argparse
import json
import os
import getpass
import subprocess
from pathlib import Path

from typing import List, Optional, Tuple

logerr = lambda s: print(f"\033[91m{s}\033[0m")
logdebug = lambda s: print(f"\033[95m[DEBUG] \033[0m{s}")
loginfo = lambda s: print(f"\033[96m{s}\033[0m")
logwarn = lambda s: print(f"\033[33m{s}\033[0m")

try:
    import argcomplete
except Exception:
    from unittest.mock import MagicMock

    argcomplete = MagicMock()
    argcomplete.autocomplete = lambda x: logwarn(
        "There is no tab completion supported since no argcomplete found!"
    )

HOME = os.getenv("HOME")
CUID, CGID = os.getuid(), os.getgid()
CUSERNAME = getpass.getuser()
CWD = os.getcwd()

PROJECT_ROOT = os.path.dirname(
    os.path.dirname(os.path.realpath(os.path.abspath(__file__)))
)
DEFAULT_DEPLOY_CONF = os.path.join(PROJECT_ROOT, "script/dev_deploy_conf.json")
DEFAULT_CONTAINER_CONFIG_PATH = "/etc/hstream/config.yaml"

ssh_cmd = ""

ADMIN_OPTS = (
    f"--enable-maintenance-manager "
    f"--enable-safety-check-periodic-metadata-update "
    f"--maintenance-log-snapshotting "
    f"--enable-safety-check-periodic-metadata-update "
)


def parse_roles(role: str) -> str:
    if role == "Both" or role == "both":
        return "--roles storage,sequencer "
    elif role == "Storage" or role == "storage":
        return "--roles storage "
    elif role == "Sequencer" or role == "sequencer":
        return "--roles sequencer "
    else:
        raise f"Unknown roles: {role}"


def run_sh(
    sh, stderr=subprocess.STDOUT, stdout=None, check=True, print_cmd=False
):
    if sh:
        if print_cmd:
            loginfo(f"Run command: <{sh}>")
        if isinstance(sh, str):
            args = ["bash", "-c", sh]
            return subprocess.run(
                args, stderr=stderr, stdout=stdout, check=check
            )
        elif isinstance(sh, list):
            return subprocess.run(
                sh, shell=True, stderr=stderr, stdout=stdout, check=check
            )
        else:
            raise ValueError(f"Invalid sh: {sh}")


def wait_tcp_sh(port, host="127.0.0.1", timeout=20):
    return (
        f'set -e && export timeout="{timeout}" && '
        f"until (echo -n > /dev/tcp/{host}/{port}); do"
        f'  >&2 echo "Waiting for {host}:{port} ...";'
        "   sleep 1;"
        "   timeout=$((timeout - 1));"
        '   if [ $timeout -le 0 ]; then echo "Timeout!" && exit 1; fi;'
        "done"
    )


def is_container_running(remote, container_name, container_bin="docker"):
    if not container_bin:
        return logerr("No such container_bin")
    result = run_sh(
        f"{ssh_cmd}{remote} '{container_bin} " "ps --format {{.Names}}'",
        stdout=subprocess.PIPE,
    )
    if result and result.stdout:
        rs = result.stdout.decode().strip().split("\n")
        if container_name.strip() in rs:
            return True
    return False


def scp_command(local_file, remote, user, key, remote_file) -> str:
    cmd = ""
    file_dir = os.path.dirname(remote_file)
    if file_dir != "":
        cmd += f"{ssh_cmd}{remote} 'mkdir -p {file_dir}' && "
    cmd += f"scp -i {key} -r {local_file} {user}@{remote}:{file_dir}"
    return cmd


def set_rm_intermediate(rm: bool) -> str:
    return " --rm " if rm else ""


def set_config_path(custom: str, origin: str) -> str:
    return f" -v {custom}:{origin} "


def set_resource_constraints(memory_cpus: Tuple[str, str]) -> str:
    memory, cpus = memory_cpus
    return (
        f" --memory={memory} "
        if memory
        else "" f" --cpus={cpus} "
        if cpus
        else ""
    )


def synchronize_configs(
    user: str,
    key: str,
    local_config_path: str,
    remote_config_path: str,
    hosts: List[Tuple[str, str]],
) -> List[str]:
    cmds = []
    if local_config_path is not None:
        assert remote_config_path is not None
        for (remote, _) in hosts:
            cmds.append(
                scp_command(
                    local_config_path, remote, user, key, remote_config_path
                )
            )
    return cmds


def set_restart(restart: bool) -> str:
    return " --restart unless-stopped " if restart else ""


# -----------------------------------------------------------------------------


class Service:
    _commands = {}

    def __init__(self, parser):
        self._parser = parser
        self._parser.add_argument("--container-bin", default="docker")
        self._parser.add_argument(
            "--remote",
            required=True,
            type=str,
            help="comma separated remote (host,local_address) pairs, e.g. server1:10.100.0.1,server2:10.100.0.2",
        )
        self._cmdparsers = parser.add_subparsers(
            title="Commands",
            dest="sub_command",
        )
        self._args = {}

    def register(self, SubService):
        s = SubService(self._cmdparsers)
        s.init_parser()
        for key in SubService.KEYS:
            if self._commands.get(key):
                raise RuntimeError(f"Register a registered service: {key}!")
            self._commands[key] = s

    def get_service(self, SubService):
        key = SubService.KEYS[0]
        if svc := self._commands.get(key):
            return svc
        else:
            raise RuntimeError(f"No such service: {key}!")

    def run(self):
        argcomplete.autocomplete(parser)
        cmds = self.parse_args()(**self._args)
        if isinstance(cmds, list):
            for cmd in cmds:
                run_sh(cmd, print_cmd=True)
        else:
            run_sh(cmds, print_cmd=True)

    def parse_args(self):
        self._args = vars(self._parser.parse_args())
        sub_command = self._args.pop("sub_command")
        if s := self._commands.get(sub_command):
            if action := self._args.pop("action_command", None):
                remotes = self.parse_remotes(self._args.pop("remote", None))
                self._args["remotes"] = remotes
                return getattr(s, f"{action.replace('-', '_')}_cmd")
            logerr(f"No such command({sub_command}) action: {action}")
            s.print_help()
        else:
            logerr(f"No such command: {sub_command}!")
            self._parser.print_help()

        return None

    @staticmethod
    def parse_remotes(remote: str) -> List[Tuple[str, str]]:
        if remote:
            remotes = remote.split(",")

            def gen(remote):
                xs = remote.split(":")
                host = xs[0]
                if len(xs) >= 2:
                    addr = xs[1]
                else:
                    result = run_sh(
                        f"ssh -G {host} | " + "awk '/^hostname / { print $2 }'",
                        stdout=subprocess.PIPE,
                    )
                    if result and result.stdout:
                        addr = result.stdout.decode().strip()
                    else:
                        raise ValueError(f"Unknown host: {remote}")
                return (host, addr)

            return [gen(r) for r in remotes]

    @staticmethod
    def stop_cmd(
        container_bin,
        container_name,
        force=False,
        remotes=None,
        **kargs,
    ):
        if remotes:
            return [
                f"{ssh_cmd}{host} '{container_bin} rm -f {container_name}'"
                if force
                else f"{ssh_cmd}{host} '{container_bin} kill {container_name}'"
                for (host, _) in remotes
            ]

    def remove_cmd(
        self,
        remotes,
        persistent_dir,
        container_bin,
        container_name,
        remove_container=True,
        **kwargs,
    ):
        cmd = (
            f"{container_bin} rm -f {container_name} &&"
            if remove_container
            else ""
        )
        return [
            f"{ssh_cmd}{host} '{cmd} sudo rm -rf {persistent_dir}'"
            for (host, _) in remotes
        ]

    @staticmethod
    def post_start_cmd(
        container_bin,
        container_name,
        port=None,
        command="",
        remotes=None,
        **kargs,
    ):
        if remotes and command:
            ports_ = port.split(",") if port else []
            wait = "".join(f"{wait_tcp_sh(p)} && " for p in ports_ if p)
            return [
                f"{ssh_cmd}{host} -t '{wait} {container_bin} exec -it {container_name} {command}' "
                for (host, _) in remotes
            ]


class ZookeeperService(Service):
    KEYS = ["zookeeper", "zk"]
    DEFAULT_CONTAINER_NAME = "deploy_zookeeper"
    DEFAULT_PERSISTENT_DIR = "/data/zookeeper"
    DEFAULT_IMAGE_TAG = "docker.io/zookeeper:3.6"
    DEFAULT_METRICS_PORT = 7070

    def __init__(self, cmdparsers):
        self._cmdparsers = cmdparsers
        self.cmd = self._cmdparsers.add_parser(
            self.KEYS[0], aliases=self.KEYS[1:], help="Manage zookeeper service"
        )

    def init_parser(self):
        self.cmd.add_argument(
            "--container-name", default=self.DEFAULT_CONTAINER_NAME
        )
        self.cmd.add_argument(
            "--extra-container-options",
            required=False,
            default="",
            type=str,
        )
        action_subparser = self.cmd.add_subparsers(
            title="action", dest="action_command"
        )

        # ------------------------------
        # zookeeper start
        start_parser = argparse.ArgumentParser(add_help=False)
        start_parser.add_argument(
            "--image", default=ZookeeperService.DEFAULT_IMAGE_TAG
        )
        start_parser.add_argument("--rm", action="store_true")
        start_parser.add_argument("--container-cmd", default="")
        start_parser.add_argument(
            "--persistent-dir",
            default=self.DEFAULT_PERSISTENT_DIR,
            help="where to store datas",
        )
        action_subparser.add_parser(
            "start", help="start sevices", parents=[start_parser]
        )
        # ------------------------------
        # zookeeper stop
        stop_parser = argparse.ArgumentParser(add_help=False)
        stop_parser.add_argument(
            "--force", "-f", default=False, action="store_true"
        )
        action_subparser.add_parser(
            "stop", help="stop services", parents=[stop_parser]
        )
        # ------------------------------
        # zookeeper remove
        remove_parser = argparse.ArgumentParser(add_help=False)
        remove_parser.add_argument(
            "--persistent-dir",
            default=self.DEFAULT_PERSISTENT_DIR,
            help="where to remove datas",
        )
        action_subparser.add_parser(
            "remove", help="remove sevices", parents=[remove_parser]
        )
        # ------------------------------
        # zookeeper post-start
        post_start_parser = argparse.ArgumentParser(add_help=False)
        post_start_parser.add_argument("--command", required=True, type=str)
        post_start_parser.add_argument(
            "--port",
            required=False,
            type=str,
            default=None,
            help="comma separated ports",
        )
        action_subparser.add_parser(
            "post-start",
            help="run command inside the container",
            parents=[post_start_parser],
        )
        # ------------------------------
        # zookeeper store
        store_parser = argparse.ArgumentParser(add_help=False)
        store_parser.add_argument(
            "--key",
            "-k",
            required=True,
            type=str,
            help="node name need to create",
        )
        store_values_group = store_parser.add_mutually_exclusive_group(
            required=True
        )
        store_values_group.add_argument(
            "--file", type=str, help="the path of file need to store"
        )
        store_values_group.add_argument(
            "--value", help="the value need to store"
        )
        action_subparser.add_parser(
            "store",
            help="create a zk node with specific name and value. ignore the operation if node exist.",
            parents=[store_parser],
        )

    def print_help(self):
        return self.cmd.print_help()

    def start_cmd(
        self,
        container_bin,
        remotes,
        container_name,
        image,
        memory_cpus,
        persistent_dir=None,
        extra_container_options="",
        container_cmd="",
        rm=False,
        metrics_provider=False,
        restart=True,
        **kargs,
    ):

        docker_opts = ""
        docker_opts += set_rm_intermediate(rm)
        docker_opts += set_resource_constraints(memory_cpus)
        docker_opts += set_restart(restart)

        zoo_servers = " ".join(
            f"server.{i + 1}={hostname}:2888:3888;2181"
            for (i, (_, hostname)) in enumerate(remotes)
        )
        pre_cmd = ""
        if persistent_dir:
            persistent_dir = persistent_dir.rstrip("/")
            pre_cmd = f"mkdir -p {persistent_dir}" + "/{data,datalog} && "
            docker_opts += set_config_path(f"{persistent_dir}/data", "/data")
            docker_opts += set_config_path(
                f"{persistent_dir}/datalog", "/datalog"
            )

        cmds = []
        for (i, (host, _)) in enumerate(remotes):
            if is_container_running(host, container_name, container_bin):
                logwarn(f"Service {self.KEYS[0]} already running.")
            else:
                enable_metrics_provider = (
                    f'-e ZOO_CFG_EXTRA="metricsProvider.className='
                    f"org.apache.zookeeper.metrics.prometheus.PrometheusMetricsProvider "
                    f'metricsProvider.httpPort={self.DEFAULT_METRICS_PORT}"'
                    if metrics_provider
                    else ""
                )

                cmds.append(
                    f"{ssh_cmd}{host} '{pre_cmd} "
                    f"{container_bin} run -td "
                    f"{docker_opts} --name {container_name} "
                    # according to https://hub.docker.com/_/zookeeper, ZOO_MY_ID must between 1 and 255
                    f'-e ZOO_MY_ID={i + 1} -e ZOO_SERVERS="{zoo_servers}" '
                    f"{enable_metrics_provider} "
                    f"--network host {extra_container_options} "
                    f"{image} {container_cmd}' "
                )

        return cmds

    @staticmethod
    def store_cmd(
        container_bin: str,
        container_name: str,
        key: str,
        value: Optional[str],
        file: Optional[str],
        remotes: List[Tuple[str, str]] = None,
        **kargs,
    ) -> List[str]:
        if not key.startswith("/"):
            key = "/" + key

        if remotes:
            node_value = value if value else f'"$(cat {file})"'

            waiting = "".join(
                f"{wait_tcp_sh(2181, h)} && sleep 2" for (_, h) in remotes
            )
            store_command = lambda host: (
                f"printf -v __ %q "
                f"{node_value} "
                f'&& {ssh_cmd}{host} "'
                f"{waiting} && "
                f"{container_bin} exec -t {container_name} zkCli.sh create {key} $__ || "
                f"{container_bin} exec -t {container_name} zkCli.sh set {key} $__"
                f'"'
            )
            return [store_command(host) for (host, _) in remotes]


class HStoreAdminService(Service):
    KEYS = ["hstore-admin"]
    DEFAULT_CONTAINER_NAME = "deploy_hstore_admin"
    DEFAULT_IMAGE_TAG = "docker.io/hstreamdb/hstream"
    BOOTSTRAP_CMD = (
        "hadmin store nodes-config bootstrap --metadata-replicate-across "
    )
    DEFAULT_ADMIN_LISTEN_PORT = 6441
    # TCP port on which the server listens to for admin commands, supports commands over SSL
    DEFAULT_ADMIN_API_PORT = 6440
    # TCP port on which the server listens for non-SSL clients
    DEFAULT_SERVER_LISTEN_PORT = 16111

    def __init__(self, cmdparsers):
        self._cmdparsers = cmdparsers
        self.cmd = self._cmdparsers.add_parser(
            self.KEYS[0],
            aliases=self.KEYS[1:],
            help="Manage logdevice admin service",
        )

    def init_parser(self):
        self.cmd.add_argument(
            "--container-name", default=self.DEFAULT_CONTAINER_NAME
        )
        self.cmd.add_argument(
            "--extra-container-options",
            required=False,
            default="",
            type=str,
        )
        action_subparser = self.cmd.add_subparsers(
            title="action", dest="action_command"
        )

        # ------------------------------
        # hstore-admin start
        start_parser = argparse.ArgumentParser(add_help=False)
        start_parser.add_argument(
            "--image", default=HStoreAdminService.DEFAULT_IMAGE_TAG
        )
        start_parser.add_argument("--rm", action="store_true")
        start_parser.add_argument(
            "--config-path",
            required=True,
            help="Zookeeper key to the config file",
        )
        action_subparser.add_parser(
            "start", help="start sevices", parents=[start_parser]
        )
        # ------------------------------
        # hstore-admin post-start
        post_start_parser = argparse.ArgumentParser(add_help=False)
        post_start_parser.add_argument(
            "--command",
            "-c",
            help="command to run inside the container",
        )
        post_start_parser.add_argument(
            "--port",
            required=False,
            type=str,
            default=None,
            help="comma separated ports",
        )
        action_subparser.add_parser(
            "post-start",
            help="run command inside the container",
            parents=[post_start_parser],
        )
        # ------------------------------
        # hstore-admin stop
        stop_parser = argparse.ArgumentParser(add_help=False)
        stop_parser.add_argument(
            "--force", "-f", default=False, action="store_true"
        )
        action_subparser.add_parser(
            "stop", help="stop services", parents=[stop_parser]
        )
        # ------------------------------
        # hstore-admin bootstrap
        bootstrap_parser = argparse.ArgumentParser(add_help=False)
        bootstrap_parser.add_argument(
            "--replicates",
            "-r",
            required=True,
            help="number of replications of metadata logs",
        )
        bootstrap_parser.add_argument(
            "--server-list",
            "-s",
            required=True,
            type=str,
            help="comma separated hstore server (host,local_address) pairs, e.g. server1:10.100.0.1,server2:10.100.0.2",
        )
        bootstrap_parser.add_argument(
            "--wait",
            type=int,
            default=4,
            help="wait time in seconds for internal information synchronization before bootstrap.",
        )
        action_subparser.add_parser(
            "bootstrap",
            help="bootstrap hstore cluster",
            parents=[bootstrap_parser],
        )

    def print_help(self):
        return self.cmd.print_help()

    # start hstore-admin
    def start_cmd(
        self,
        container_bin,
        container_name,
        remotes,
        image,
        memory_cpus,
        config_path,
        extra_container_options="",
        rm=False,
        restart=True,
        **kargs,
    ):
        docker_opts = ""
        docker_opts += set_rm_intermediate(rm)
        docker_opts += set_resource_constraints(memory_cpus)
        docker_opts += set_restart(restart)

        cmds = []
        for (host, _) in remotes:
            if is_container_running(host, container_name, container_bin):
                logwarn(f"Service {self.KEYS[0]} already running.")
            else:
                cmds.append(
                    f"{ssh_cmd}{host} '"
                    f"{container_bin} run -d "
                    f"{docker_opts} "
                    f"--name {container_name} "
                    f"--network host {image} /usr/local/bin/ld-admin-server "
                    f"--config-path {config_path} "
                    f"--enable-maintenance-manager "
                    f"--maintenance-log-snapshotting "
                    f"--enable-safety-check-periodic-metadata-update "
                    f"--admin-port {self.DEFAULT_ADMIN_LISTEN_PORT} "
                    f"'"
                )

        return cmds

    def bootstrap_cmd(
        self,
        container_bin: str,
        container_name: str,
        remotes: List[Tuple[str, str]],
        server_list: str,
        replicates: int,
        wait: int,
        admin_port: int,
        **kargs,
    ) -> List[str]:
        servers = self.parse_remotes(server_list)
        if servers and remotes:
            wait_port = "".join(
                f"{wait_tcp_sh(self.DEFAULT_ADMIN_API_PORT, store_host)} && "
                f"{wait_tcp_sh(self.DEFAULT_SERVER_LISTEN_PORT, store_host)} && "
                for (_, store_host) in servers
            )

            return [
                f"{ssh_cmd}{host} -t "
                f"'{wait_port} sleep {wait} && "
                f"{container_bin} exec -it {container_name} {self.BOOTSTRAP_CMD} node:{replicates} --port {admin_port} '"
                for (host, _) in remotes
            ]


class HStoreService(Service):
    KEYS = ["hstore"]
    DEFAULT_CONTAINER_NAME = "deploy_hstore"
    DEFAULT_PERSISTENT_DIR = "/data/store"
    DEFAULT_IMAGE_TAG = "docker.io/hstreamdb/hstream"

    def __init__(self, cmdparsers):
        self._cmdparsers = cmdparsers
        self.cmd = self._cmdparsers.add_parser(
            self.KEYS[0],
            aliases=self.KEYS[1:],
            help="Manage logdevice service",
        )

    def init_parser(self):
        self.cmd.add_argument(
            "--container-name", default=self.DEFAULT_CONTAINER_NAME
        )
        self.cmd.add_argument(
            "--extra-container-options",
            required=False,
            default="",
            type=str,
        )
        action_subparser = self.cmd.add_subparsers(
            title="action", dest="action_command"
        )

        # ------------------------------
        # hstore start
        start_parser = argparse.ArgumentParser(add_help=False)
        start_parser.add_argument(
            "--image", default=HStoreService.DEFAULT_IMAGE_TAG
        )
        start_parser.add_argument("--rm", action="store_true")
        start_parser.add_argument(
            "--data-dir", default=self.DEFAULT_PERSISTENT_DIR
        )
        start_parser.add_argument("--shards", default=1, type=int)
        start_parser.add_argument(
            "--config-path",
            required=True,
            help="Zookeeper key to the config file",
        )
        action_subparser.add_parser(
            "start", help="start sevices", parents=[start_parser]
        )
        # ------------------------------
        # hstore stop
        stop_parser = argparse.ArgumentParser(add_help=False)
        stop_parser.add_argument(
            "--force", "-f", default=False, action="store_true"
        )
        action_subparser.add_parser(
            "stop", help="stop services", parents=[stop_parser]
        )
        # ------------------------------
        # hstore remove
        remove_parser = argparse.ArgumentParser(add_help=False)
        remove_parser.add_argument(
            "--persistent-dir",
            default=self.DEFAULT_PERSISTENT_DIR,
            help="where to remove datas",
        )
        action_subparser.add_parser(
            "remove",
            help="remove store service",
            parents=[remove_parser],
        )

    def print_help(self):
        return self.cmd.print_help()

    def start_cmd(
        self,
        container_bin: str,
        container_name: str,
        image: str,
        memory_cpus: Tuple[str, str],
        data_dir: str,
        shards: int,
        config_path: str,
        remotes: List[Tuple[str, str]],
        disks: int,
        roles: List[str],
        rm: bool = False,
        restart: bool = True,
        **kargs,
    ) -> List[str]:
        docker_opts = ""
        docker_opts += set_rm_intermediate(rm)
        docker_opts += set_resource_constraints(memory_cpus)
        docker_opts += set_restart(restart)

        cmds = []
        shards_path = Path(data_dir).joinpath("NSHARDS")
        for (i, (host, addr)) in enumerate(remotes):
            if is_container_running(host, container_name, container_bin):
                logwarn(f"Service {self.KEYS[0]} already running.")
            else:
                mnt_cmd = " && ".join(
                    [
                        f"mkdir -p /mnt/data{j % disks}/shard{j} && ln -s /mnt/data{j % disks}/shard{j} {data_dir}/shard{j}"
                        for j in range(shards)
                    ]
                )
                cmds.append(
                    f"{ssh_cmd}{host} '"
                    f"mkdir -p {data_dir} && echo {shards} | tee {shards_path} && "
                    f"{mnt_cmd} && "
                    f"{container_bin} run -d "
                    f"{docker_opts} "
                    f"--name {container_name} "
                    f"--network host "
                    f"-v {data_dir}:{data_dir} "
                    f"-v /mnt:/mnt "
                    f"{image} /usr/local/bin/logdeviced "
                    f"--config-path {config_path} "
                    f"--name ld_{i} --address {addr} "
                    f"--local-log-store-path {data_dir} "
                    f"--num-shards {shards} "
                    f"{roles[i]} "
                    f"'"
                )
        return cmds

    def remove_cmd(
        self,
        remotes,
        persistent_dir,
        container_bin,
        container_name,
        remove_container=True,
        shards=1,
        **kwargs,
    ):
        cmd = (
            f"{container_bin} rm -f {container_name} &&"
            if remove_container
            else ""
        )
        # rm -rf persistent_dir/shard*/* will clear all data in each shard first, this used to make
        # sure data cleared when shard directories are symbolic links
        clean_cmd = f"sudo rm -rf {persistent_dir}/shard*/* {persistent_dir}"
        return [
            f"{ssh_cmd}{host} '{cmd} {clean_cmd} '" for (host, _) in remotes
        ]


class HServerService(Service):
    KEYS = ["hserver"]
    DEFAULT_CONTAINER_NAME = "deploy_hserver"
    DEFAULT_IMAGE_TAG = "docker.io/hstreamdb/hstream"

    def __init__(self, cmdparsers):
        self._cmdparsers = cmdparsers
        self.cmd = self._cmdparsers.add_parser(
            self.KEYS[0],
            aliases=self.KEYS[1:],
            help="Manage hserver service",
        )
        self._server_id = 1

    def init_parser(self):
        self.cmd.add_argument(
            "--container-name", default=self.DEFAULT_CONTAINER_NAME
        )
        self.cmd.add_argument(
            "--extra-container-options",
            required=False,
            default="",
            type=str,
        )
        start_parser = argparse.ArgumentParser(add_help=False)
        start_parser.add_argument(
            "--image", default=HServerService.DEFAULT_IMAGE_TAG
        )
        start_parser.add_argument("--rm", action="store_true")
        start_parser.add_argument(
            "--store-config",
            required=True,
            help="Zookeeper key to the store config file",
        )
        start_parser.add_argument(
            "--config-path",
            help="HStreamDB configuration file path",
        )
        start_parser.add_argument(
            "--store-admin-host",
            required=True,
        )
        start_parser.add_argument("--zkuri", required=True)
        stop_parser = argparse.ArgumentParser(add_help=False)
        stop_parser.add_argument(
            "--force", "-f", default=False, action="store_true"
        )
        action_subparser = self.cmd.add_subparsers(
            title="action", dest="action_command"
        )
        action_subparser.add_parser(
            "start", help="start sevices", parents=[start_parser]
        )
        action_subparser.add_parser(
            "stop", help="stop services", parents=[stop_parser]
        )

    def print_help(self):
        return self.cmd.print_help()

    def start_cmd(
        self,
        container_bin,
        container_name,
        image,
        memory_cpus,
        zkuri,
        store_config,
        store_admin_host,
        remotes,
        extra_container_options="",
        rm=False,
        config_path=None,
        restart=True,
        **kargs,
    ):
        docker_opts = ""
        docker_opts += set_rm_intermediate(rm)
        docker_opts += set_resource_constraints(memory_cpus)
        docker_opts += set_restart(restart)

        if config_path is not None:
            docker_opts += set_config_path(
                config_path, DEFAULT_CONTAINER_CONFIG_PATH
            )
        cmds = []
        seed_address = remotes[0][1]
        for (i, (host, addr)) in enumerate(remotes):
            if is_container_running(host, container_name, container_bin):
                logwarn(f"Service {self.KEYS[0]} already running.")
            else:
                cmds.append(
                    f"{ssh_cmd}{host} '"
                    f"{container_bin} run -d "
                    f"{docker_opts} "
                    f"--name {container_name} "
                    f"--network host "
                    f"{image} /usr/local/bin/hstream-server "
                    f"--host {addr} "
                    f"--address {addr} "
                    f"--config-path {DEFAULT_CONTAINER_CONFIG_PATH} "
                    f"--zkuri {zkuri} "
                    f"--store-config {store_config} "
                    f"--store-admin-host {store_admin_host} "
                    f"--server-id {i} "
                    f"--store-log-level error "
                    f"--seed-nodes {seed_address} "
                    f"'"
                )
        return cmds


class PrometheusService(Service):
    KEYS = ["prometheus"]
    DEFAULT_CONTAINER_NAME = "deploy_prometheus"
    DEFAULT_PERSISTENT_DIR = "/data/prometheus"
    DEFAULT_IMAGE_TAG = "docker.io/prom/prometheus"

    def __init__(self, cmdparsers):
        self._cmdparsers = cmdparsers
        self.cmd = self._cmdparsers.add_parser(
            self.KEYS[0],
            aliases=self.KEYS[1:],
            help="Manage prometheus service",
        )

    def init_parser(self):
        self.cmd.add_argument(
            "--container-name", default=self.DEFAULT_CONTAINER_NAME
        )
        self.cmd.add_argument(
            "--extra-container-options",
            required=False,
            default="",
            type=str,
        )
        start_parser = argparse.ArgumentParser(add_help=False)
        start_parser.add_argument(
            "--image", default=PrometheusService.DEFAULT_IMAGE_TAG
        )
        start_parser.add_argument("--rm", action="store_true")
        start_parser.add_argument(
            "--prometheus-config",
            help="Prometheus configuration file path",
        )
        stop_parser = argparse.ArgumentParser(add_help=False)
        stop_parser.add_argument(
            "--force", "-f", default=False, action="store_true"
        )
        action_subparser = self.cmd.add_subparsers(
            title="action", dest="action_command"
        )
        action_subparser.add_parser(
            "start", help="start sevices", parents=[start_parser]
        )
        action_subparser.add_parser(
            "stop", help="stop services", parents=[stop_parser]
        )

    def print_help(self):
        return self.cmd.print_help()

    def start_cmd(
        self,
        container_bin,
        container_name,
        remotes,
        image,
        memory_cpus,
        rm=False,
        config_path=None,
        restart=True,
        **args,
    ):
        docker_opts = ""
        docker_opts += set_rm_intermediate(rm)
        docker_opts += set_resource_constraints(memory_cpus)
        docker_opts += set_restart(restart)
        if config_path is not None:
            docker_opts += set_config_path(config_path, "/etc/prometheus")

        cmds = []
        for (host, _) in remotes:
            if is_container_running(host, container_name, container_bin):
                logwarn(f"Service {self.KEYS[0]} already running.")
            else:
                cmds.append(
                    f"{ssh_cmd}{host} '"
                    f"{container_bin} run -d "
                    f"{docker_opts} "
                    f"--name {container_name} "
                    f"--network host "
                    f"{image}"
                    f"'"
                )
        return cmds


class NodeExporterService(Service):
    KEYS = ["node-exporter"]
    DEFAULT_CONTAINER_NAME = "deploy_node_exporter"
    DEFAULT_IMAGE_TAG = "docker.io/prom/node-exporter"

    def __init__(self, cmdparsers):
        self._cmdparsers = cmdparsers
        self.cmd = self._cmdparsers.add_parser(
            self.KEYS[0],
            aliases=self.KEYS[1:],
            help="Manage node-exporter service",
        )

    def init_parser(self):
        self.cmd.add_argument(
            "--container-name", default=self.DEFAULT_CONTAINER_NAME
        )
        self.cmd.add_argument(
            "--extra-container-options",
            required=False,
            default="",
            type=str,
        )
        start_parser = argparse.ArgumentParser(add_help=False)
        start_parser.add_argument(
            "--image", default=NodeExporterService.DEFAULT_IMAGE_TAG
        )
        start_parser.add_argument("--rm", action="store_true")
        stop_parser = argparse.ArgumentParser(add_help=False)
        stop_parser.add_argument(
            "--force", "-f", default=False, action="store_true"
        )
        action_subparser = self.cmd.add_subparsers(
            title="action", dest="action_command"
        )
        action_subparser.add_parser(
            "start", help="start sevices", parents=[start_parser]
        )
        action_subparser.add_parser(
            "stop", help="stop services", parents=[stop_parser]
        )

    def print_help(self):
        return self.cmd.print_help()

    def start_cmd(
        self,
        container_bin,
        container_name,
        remotes,
        image,
        memory_cpus,
        rm=False,
        restart=True,
        **args,
    ):
        docker_opts = ""
        docker_opts += set_rm_intermediate(rm)
        docker_opts += set_resource_constraints(memory_cpus)
        docker_opts += set_restart(restart)
        cmds = []

        for (host, _) in remotes:
            if is_container_running(host, container_name, container_bin):
                logwarn(f"Service {self.KEYS[0]} already running.")
            else:
                cmds.append(
                    f"{ssh_cmd}{host} '"
                    f"{container_bin} run -d "
                    f"{docker_opts} "
                    f"--name {container_name} "
                    f"--network host "
                    f"{image}"
                    f"'"
                )
        return cmds


class CadvisorService(Service):
    KEYS = ["cadvisor"]
    DEFAULT_CONTAINER_NAME = "deploy_cadvisor"
    DEFAULT_IMAGE_TAG = "gcr.io/cadvisor/cadvisor:v0.39.3"
    DEFAULT_METRICS_PORT = 7000

    def __init__(self, cmdparsers):
        self._cmdparsers = cmdparsers
        self.cmd = self._cmdparsers.add_parser(
            self.KEYS[0],
            aliases=self.KEYS[1:],
            help="Manage cadvisor service",
        )

    def init_parser(self):
        self.cmd.add_argument(
            "--container-name", default=self.DEFAULT_CONTAINER_NAME
        )
        self.cmd.add_argument(
            "--extra-container-options",
            required=False,
            default="",
            type=str,
        )
        start_parser = argparse.ArgumentParser(add_help=False)
        start_parser.add_argument(
            "--image", default=CadvisorService.DEFAULT_IMAGE_TAG
        )
        start_parser.add_argument("--rm", action="store_true")
        stop_parser = argparse.ArgumentParser(add_help=False)
        stop_parser.add_argument(
            "--force", "-f", default=False, action="store_true"
        )
        action_subparser = self.cmd.add_subparsers(
            title="action", dest="action_command"
        )
        action_subparser.add_parser(
            "start", help="start sevices", parents=[start_parser]
        )
        action_subparser.add_parser(
            "stop", help="stop services", parents=[stop_parser]
        )

    def print_help(self):
        return self.cmd.print_help()

    def start_cmd(
        self,
        container_bin,
        container_name,
        remotes,
        image,
        memory_cpus,
        rm=False,
        restart=True,
        port=DEFAULT_METRICS_PORT,
        **args,
    ):
        docker_opts = ""
        docker_opts += set_rm_intermediate(rm)
        docker_opts += set_resource_constraints(memory_cpus)
        docker_opts += set_restart(restart)
        cmds = []

        for (host, _) in remotes:
            if is_container_running(host, container_name, container_bin):
                logwarn(f"Service {self.KEYS[0]} already running.")
            else:
                cmds.append(
                    f"{ssh_cmd}{host} '"
                    f"{container_bin} run -d "
                    f"{docker_opts} "
                    f"--name {container_name} "
                    f"-v /:/rootfs:ro "
                    f"-v /var/run:/var/run:ro "
                    f"-v /sys:/sys:ro "
                    f"-v /var/lib/docker/:/var/lib/docker:ro "
                    f"-v /dev/disk/:/dev/disk:ro "
                    f"-p {port}:8080 "
                    f"--detach=true "
                    f"--privileged=true "
                    f"--device /dev/kmsg "
                    f"{image}"
                    f"'"
                )
        return cmds


class GrafanaService(Service):
    KEYS = ["grafana"]
    DEFAULT_CONTAINER_NAME = "deploy_grafana"
    DEFAULT_IMAGE_TAG = "docker.io/grafana/grafana-oss:main"

    NO_LOGIN_ENV_OPTS = "".join(
        [
            " -e GF_AUTH_ANONYMOUS_ORG_ROLE=Admin ",
            " -e GF_AUTH_ANONYMOUS_ENABLED=true ",
            " -e GF_AUTH_DISABLE_LOGIN_FORM=true ",
        ]
    )

    def __init__(self, cmdparsers):
        self._cmdparsers = cmdparsers

        self.cmd = self._cmdparsers.add_parser(
            self.KEYS[0],
            aliases=self.KEYS[1:],
            help="Manage grafana service",
        )

    def init_parser(self):
        self.cmd.add_argument(
            "--container-name", default=self.DEFAULT_CONTAINER_NAME
        )
        self.cmd.add_argument(
            "--extra-container-options",
            required=False,
            default="",
            type=str,
        )
        start_parser = argparse.ArgumentParser(add_help=False)
        start_parser.add_argument(
            "--image", default=GrafanaService.DEFAULT_IMAGE_TAG
        )
        start_parser.add_argument("--rm", action="store_true")
        stop_parser = argparse.ArgumentParser(add_help=False)
        stop_parser.add_argument(
            "--force", "-f", default=False, action="store_true"
        )
        action_subparser = self.cmd.add_subparsers(
            title="action", dest="action_command"
        )
        action_subparser.add_parser(
            "start", help="start services", parents=[start_parser]
        )
        action_subparser.add_parser(
            "stop", help="stop services", parents=[stop_parser]
        )

    def print_help(self):
        return self.cmd.print_help()

    def start_cmd(
        self,
        container_bin,
        container_name,
        remotes,
        image,
        memory_cpus,
        rm=False,
        restart=True,
        disable_login=True,
        config_path=None,
        provisioning_path=None,
        **args,
    ):
        docker_opts = ""
        docker_opts += set_rm_intermediate(rm)
        docker_opts += set_resource_constraints(memory_cpus)
        docker_opts += set_restart(restart)

        docker_opts += self.NO_LOGIN_ENV_OPTS if disable_login else ""
        docker_opts += (
            set_config_path(config_path, "/etc/grafana/grafana.ini")
            if config_path is not None
            else ""
        )
        docker_opts += (
            set_config_path(provisioning_path, "/etc/grafana/provisioning")
            if provisioning_path is not None
            else ""
        )

        cmds = []

        for (host, _) in remotes:
            if is_container_running(host, container_name, container_bin):
                logwarn(f"Service {self.KEYS[0]} already running.")
            else:
                cmds.append(
                    f"{ssh_cmd}{host} '"
                    f"{container_bin} run -d "
                    f"--network host "
                    f"{docker_opts} "
                    f"--name {container_name} "
                    f"{image}'"
                )

        return cmds


class SimpleService(Service):
    KEYS = ["simple"]
    DEFAULT_CONTAINER_BIN = "docker"
    DEFAULT_STORE_CONFIG_NODE_IN_ZK = "/logdevice.conf"
    ALL_SERVICES = [
        "zk",
        "hstore",
        "hadmin",
        "hserver",
        "prometheus",
        "node-exporter",
    ]

    def __init__(self, cmdparsers):
        self._cmdparsers = cmdparsers
        self.cmd = self._cmdparsers.add_parser(
            self.KEYS[0],
            aliases=self.KEYS[1:],
            help="Cluster deploy service",
        )
        self.ZK_SVC = super().get_service(ZookeeperService)
        self.HSTORE_ADMIN_SVC = super().get_service(HStoreAdminService)
        self.HSTORE_SVC = super().get_service(HStoreService)
        self.HSERVER_SVC = super().get_service(HServerService)
        self.PROMETHEUS_SVC = super().get_service(PrometheusService)
        self.NODE_EXPORTER_SVC = super().get_service(NodeExporterService)
        self.CADVISOR_SVC = super().get_service(CadvisorService)
        self.GRAFANA_SVC = super().get_service(GrafanaService)

    def init_parser(self):
        self.cmd.add_argument("--config", default=DEFAULT_DEPLOY_CONF)
        self.cmd.add_argument("--user", default="root")
        self.cmd.add_argument("--key", help="ssh key file path")

        action_subparser = self.cmd.add_subparsers(
            title="action", dest="action_command"
        )

        start_parser = argparse.ArgumentParser(add_help=False)
        total_choices = SimpleService.ALL_SERVICES[:]
        total_choices.append("all")
        start_parser.add_argument(
            "--disable-restart",
            choices=total_choices,
            nargs="+",
            default=[],
            help="disable container restart strategy.",
        )
        action_subparser.add_parser(
            "start", help="start services", parents=[start_parser]
        )

        action_subparser.add_parser("stop", help="stop services")
        action_subparser.add_parser("remove", help="remove persistent data")

    def parse_config(self, config):
        with open(config, "r") as f:
            deploy_cfg = json.load(f)
            # self.zk_hosts = parse_host(deploy_cfg["zookeeper"]["hosts"])
            self.zk_hosts = [
                # (host, deploy_cfg["hosts"][host])
                (deploy_cfg["hosts"][host][0], deploy_cfg["hosts"][host][1])
                for host in (deploy_cfg["zookeeper"])["hosts"]
            ]
            self.zk_ip = ",".join(map(lambda x: x[1] + ":2181", self.zk_hosts))
            # config_path_in_zk: zk:host1:2181,host2:2181/logdevice.conf
            self.config_path_in_zk = (
                "zk:" + self.zk_ip + self.DEFAULT_STORE_CONFIG_NODE_IN_ZK
            )

            self.admin_hosts = []
            admin = deploy_cfg["hstore-admin"]["hosts"]
            self.admin_embed = deploy_cfg["hstore-admin"]["embed"]
            self.meta_replication_factor = deploy_cfg["hstore-admin"]["meta-replication"]
            if deploy_cfg["hstore-admin"]["embed"]:
                if not admin in deploy_cfg["hstore"]["hosts"]:
                    raise "hadmin node not in hstore hosts' list."
            else:
                self.admin_hosts = [
                    # (host, deploy_cfg["hosts"][host])
                    (
                        deploy_cfg["hosts"][admin][0],
                        deploy_cfg["hosts"][admin][1],
                    )
                ]

            self.hstore_hosts = []
            self.hstore_roles = []
            for (host, role) in deploy_cfg["hstore"]["hosts"].items():
                self.hstore_hosts.append(
                    (deploy_cfg["hosts"][host][0], deploy_cfg["hosts"][host][1])
                )
                role_opt = parse_roles(role)
                if deploy_cfg["hstore-admin"]["embed"] and admin == host:
                    role_opt += ADMIN_OPTS
                    self.admin_hosts = [
                        (
                            deploy_cfg["hosts"][host][0],
                            deploy_cfg["hosts"][host][1],
                        )
                    ]
                self.hstore_roles.append(role_opt)

            self.hserver_hosts = [
                # (host, deploy_cfg["hosts"][host])
                (deploy_cfg["hosts"][host][0], deploy_cfg["hosts"][host][1])
                for host in (deploy_cfg["hserver"])["hosts"]
            ]
            self.prometheus_hosts = [
                # (host, deploy_cfg["hosts"][host])
                (deploy_cfg["hosts"][host][0], deploy_cfg["hosts"][host][1])
                for host in (deploy_cfg["prometheus"])["hosts"]
            ]
            self.node_exporter_hosts = [
                # (host, deploy_cfg["hosts"][host])
                (deploy_cfg["hosts"][host][0], deploy_cfg["hosts"][host][1])
                for host in (deploy_cfg["node-exporter"])["hosts"]
            ]
            self.cadvisor_hosts = [
                # (host, deploy_cfg["hosts"][host])
                (deploy_cfg["hosts"][host][0], deploy_cfg["hosts"][host][1])
                for host in (deploy_cfg["cadvisor"])["hosts"]
            ]
            self.grafana_hosts = [
                (deploy_cfg["hosts"][host][0], deploy_cfg["hosts"][host][1])
                for host in (deploy_cfg["grafana"])["hosts"]
            ]

            self.zk_enable_metrics_provider = deploy_cfg["zookeeper"].get(
                "enable-metrics-provider"
            )
            self.hstore_local_conf = deploy_cfg["hstore"].get(
                "local_config_path"
            )
            self.hstore_remote_conf = deploy_cfg["hstore"].get(
                "remote_config_path"
            )
            self.hserver_local_conf = deploy_cfg["hserver"].get(
                "local_config_path"
            )
            self.hserver_remote_conf = deploy_cfg["hserver"].get(
                "remote_config_path"
            )
            self.prometheus_local_conf = deploy_cfg["prometheus"].get(
                "local_config_path"
            )
            self.prometheus_remote_conf = deploy_cfg["prometheus"].get(
                "remote_config_path"
            )
            self.grafana_local_conf = deploy_cfg["grafana"].get(
                "local_config_path"
            )
            self.grafana_remote_conf = deploy_cfg["grafana"].get(
                "remote_config_path"
            )

            self.zk_image = deploy_cfg["zookeeper"].get(
                "image", ZookeeperService.DEFAULT_IMAGE_TAG
            )
            self.hstore_image = deploy_cfg["hstore"].get(
                "image", HStoreService.DEFAULT_IMAGE_TAG
            )
            self.hadmin_image = deploy_cfg["hstore-admin"].get(
                "image", HStoreAdminService.DEFAULT_IMAGE_TAG
            )
            self.hserver_image = deploy_cfg["hserver"].get(
                "image", HServerService.DEFAULT_IMAGE_TAG
            )
            self.prometheus_image = deploy_cfg["prometheus"].get(
                "image", PrometheusService.DEFAULT_IMAGE_TAG
            )
            self.node_exporter_image = deploy_cfg["node-exporter"].get(
                "image", NodeExporterService.DEFAULT_IMAGE_TAG
            )
            self.cadvisor_image = deploy_cfg["cadvisor"].get(
                "image", CadvisorService.DEFAULT_IMAGE_TAG
            )
            self.grafana_image = deploy_cfg["grafana"].get(
                "image", GrafanaService.DEFAULT_IMAGE_TAG
            )

            self.cadvisor_port = deploy_cfg["cadvisor"].get(
                "port", CadvisorService.DEFAULT_METRICS_PORT
            )
            self.grafana_disable_login = deploy_cfg["grafana"].get(
                "disable-login"
            )
            self.grafana_local_provisioning_path = deploy_cfg["grafana"].get(
                "local-provisioning-path"
            )
            self.grafana_remote_provisioning_path = deploy_cfg["grafana"].get(
                "remote-provisioning-path"
            )

            self.zk_persistent_dir = deploy_cfg["zookeeper"].get(
                "persistent-dir", ZookeeperService.DEFAULT_PERSISTENT_DIR
            )
            self.hstore_persistent_dir = deploy_cfg["hstore"].get(
                "persistent-dir", HStoreService.DEFAULT_PERSISTENT_DIR
            )

            get_memory_cpus = lambda obj_name: (
                deploy_cfg[obj_name].get("memory"),
                deploy_cfg[obj_name].get("cpus"),
            )
            self.zk_memory_cpus = get_memory_cpus("zookeeper")
            self.hstore_memory_cpus = get_memory_cpus("hstore")
            self.hadmin_memory_cpus = get_memory_cpus("hstore-admin")
            self.hserver_memory_cpus = get_memory_cpus("hserver")
            self.prometheus_memory_cpus = get_memory_cpus("prometheus")
            self.node_exporter_memory_cpus = get_memory_cpus("node-exporter")
            self.cadvisor_memory_cpus = get_memory_cpus("cadvisor")
            self.grafana_memory_cpus = get_memory_cpus("grafana")

            self.shards = deploy_cfg["hstore"].get("shards", 1)
            self.disks = deploy_cfg["hstore"].get("disks", 1)

    def start_cmd(
        self, config: str, disable_restart, user: str, key: str, **kargs
    ) -> List[str]:
        self.parse_config(config)
        global ssh_cmd
        ssh_cmd = f"ssh -i {key} {user}@"
        loginfo(f"{ssh_cmd}")

        cmds = self.pre_start(user, key)

        disable_restarted = set()
        for choice in disable_restart:
            if choice == "all":
                disable_restarted.update(SimpleService.ALL_SERVICES)
            else:
                disable_restarted.add(choice)
        loginfo(f"{disable_restarted=}")

        # start zookeeper
        zk_args = {
            "container_bin": self.DEFAULT_CONTAINER_BIN,
            "container_name": ZookeeperService.DEFAULT_CONTAINER_NAME,
            "image": self.zk_image,
        }
        zk_start_args = {
            "remotes": self.zk_hosts,
            "persistent_dir": self.zk_persistent_dir,
            "metrics_provider": self.zk_enable_metrics_provider,
            "memory_cpus": self.zk_memory_cpus,
            "restart": False if "zk" in disable_restarted else True,
            **zk_args,
        }
        cmds.extend(self.ZK_SVC.start_cmd(**zk_start_args))

        zk_store_args = {
            "remotes": [self.zk_hosts[0]],
            "key": self.DEFAULT_STORE_CONFIG_NODE_IN_ZK,
            "file": self.hstore_local_conf,
            "value": None,
            **zk_args,
        }
        cmds.extend(self.ZK_SVC.store_cmd(**zk_store_args))

        zk_cmd_args = {
            "remotes": [self.zk_hosts[0]],
            "command": "zkCli.sh get " + zk_store_args["key"],
            **zk_args,
        }
        cmds.extend(self.ZK_SVC.post_start_cmd(**zk_cmd_args))

        # start hstore_admin
        if not self.admin_embed:
            admin_args = {
                "container_bin": self.DEFAULT_CONTAINER_BIN,
                "container_name": HStoreAdminService.DEFAULT_CONTAINER_NAME,
                "image": self.hadmin_image,
                "memory_cpus": self.hadmin_memory_cpus,
                "config_path": self.config_path_in_zk,
                "remotes": self.admin_hosts,
                "restart": False if "hadmin" in disable_restarted else True,
            }
            cmds.extend(self.HSTORE_ADMIN_SVC.start_cmd(**admin_args))

        # start hstore
        store_args = {
            "container_bin": self.DEFAULT_CONTAINER_BIN,
            "container_name": HStoreService.DEFAULT_CONTAINER_NAME,
            "image": self.hstore_image,
            "memory_cpus": self.hstore_memory_cpus,
            "config_path": self.config_path_in_zk,
            "data_dir": self.hstore_persistent_dir,
            # FIXME: make shards configurable
            "shards": self.shards,
            "remotes": self.hstore_hosts,
            "restart": False if "hstore" in disable_restarted else True,
            "disks": self.disks,
            "roles": self.hstore_roles,
        }
        cmds.extend(self.HSTORE_SVC.start_cmd(**store_args))

        # bootstrap
        if self.admin_embed:
            image = HStoreService.DEFAULT_CONTAINER_NAME
            admin_port = 6440
        else:
            image = HStoreAdminService.DEFAULT_CONTAINER_NAME
            admin_port = 6441
        bootstrap_args = {
            "container_bin": self.DEFAULT_CONTAINER_BIN,
            "container_name": image,
            "remotes": self.admin_hosts,
            "replicates": self.meta_replication_factor,
            "server_list": ",".join(
                map(lambda pair: f"{pair[0]}:{pair[1]}", self.hstore_hosts)
            ),
            "wait": 4,
            "admin_port": admin_port,
        }
        cmds.extend(self.HSTORE_ADMIN_SVC.bootstrap_cmd(**bootstrap_args))

        # start hserver
        server_args = {
            "container_bin": self.DEFAULT_CONTAINER_BIN,
            "container_name": HServerService.DEFAULT_CONTAINER_NAME,
            "remotes": self.hserver_hosts,
            "image": self.hserver_image,
            "memory_cpus": self.hserver_memory_cpus,
            "zkuri": self.zk_ip,
            "store_config": self.config_path_in_zk,
            "store_admin_host": self.admin_hosts[0][1],
            "config_path": self.hserver_remote_conf,
            "restart": False if "hserver" in disable_restarted else True,
        }
        cmds.extend(self.HSERVER_SVC.start_cmd(**server_args))

        # start prometheus
        prometheus_args = {
            "container_bin": self.DEFAULT_CONTAINER_BIN,
            "container_name": PrometheusService.DEFAULT_CONTAINER_NAME,
            "config_path": self.prometheus_remote_conf,
            "image": self.prometheus_image,
            "memory_cpus": self.prometheus_memory_cpus,
            "remotes": self.prometheus_hosts,
            "restart": False if "prometheus" in disable_restarted else True,
        }
        cmds.extend(self.PROMETHEUS_SVC.start_cmd(**prometheus_args))

        # start node-exporter
        node_exporter_args = {
            "container_bin": self.DEFAULT_CONTAINER_BIN,
            "container_name": NodeExporterService.DEFAULT_CONTAINER_NAME,
            "image": self.node_exporter_image,
            "memory_cpus": self.node_exporter_memory_cpus,
            "remotes": self.node_exporter_hosts,
            "restart": False if "node-exporter" in disable_restarted else True,
        }
        cmds.extend(self.NODE_EXPORTER_SVC.start_cmd(**node_exporter_args))

        # start cadvisor
        cadvisor_args = {
            "container_bin": self.DEFAULT_CONTAINER_BIN,
            "container_name": CadvisorService.DEFAULT_CONTAINER_NAME,
            "image": self.cadvisor_image,
            "memory_cpus": self.cadvisor_memory_cpus,
            "remotes": self.cadvisor_hosts,
            "restart": False if "cadvisor" in disable_restarted else True,
            "port": self.cadvisor_port,
        }
        cmds.extend(self.CADVISOR_SVC.start_cmd(**cadvisor_args))

        # start grafana
        grafana_args = {
            "container_bin": self.DEFAULT_CONTAINER_BIN,
            "container_name": GrafanaService.DEFAULT_CONTAINER_NAME,
            "image": self.grafana_image,
            "memory_cpus": self.grafana_memory_cpus,
            "remotes": self.grafana_hosts,
            "restart": False if "grafana" in disable_restarted else True,
            "disable_login": self.grafana_disable_login,
            "config_path": self.grafana_remote_conf,
            "provisioning_path": self.grafana_remote_provisioning_path,
        }
        cmds.extend(self.GRAFANA_SVC.start_cmd(**grafana_args))

        return cmds

    def stop_cmd(self, config: str, user: str, key: str, **kargs) -> List[str]:
        self.parse_config(config)
        cmds = []

        global ssh_cmd
        ssh_cmd = f"ssh -i {key} {user}@"

        # stop hserver
        server_args = {
            "container_bin": self.DEFAULT_CONTAINER_BIN,
            "container_name": HServerService.DEFAULT_CONTAINER_NAME,
            "remotes": self.hserver_hosts,
            "force": True,
        }
        cmds.extend(self.HSERVER_SVC.stop_cmd(**server_args))

        # stop hstore
        store_args = {
            "container_bin": self.DEFAULT_CONTAINER_BIN,
            "container_name": HStoreService.DEFAULT_CONTAINER_NAME,
            "remotes": self.hstore_hosts,
            "force": True,
        }
        cmds.extend(self.HSTORE_SVC.stop_cmd(**store_args))

        # stop hstore-admin
        if not self.admin_embed:
            admin_args = {
                "container_bin": self.DEFAULT_CONTAINER_BIN,
                "container_name": HStoreAdminService.DEFAULT_CONTAINER_NAME,
                "remotes": self.admin_hosts,
                "force": True,
            }
            cmds.extend(self.HSTORE_ADMIN_SVC.stop_cmd(**admin_args))

        # stop zk
        zk_args = {
            "container_bin": self.DEFAULT_CONTAINER_BIN,
            "container_name": ZookeeperService.DEFAULT_CONTAINER_NAME,
            "remotes": self.zk_hosts,
            "force": True,
        }
        cmds.extend(self.ZK_SVC.stop_cmd(**zk_args))

        # stop prometheus
        prometheus_args = {
            "container_bin": self.DEFAULT_CONTAINER_BIN,
            "container_name": PrometheusService.DEFAULT_CONTAINER_NAME,
            "remotes": self.prometheus_hosts,
            "force": True,
        }
        cmds.extend(self.PROMETHEUS_SVC.stop_cmd(**prometheus_args))

        # stop node-exporter
        node_exporter_args = {
            "container_bin": self.DEFAULT_CONTAINER_BIN,
            "container_name": NodeExporterService.DEFAULT_CONTAINER_NAME,
            "remotes": self.node_exporter_hosts,
            "force": True,
        }
        cmds.extend(self.NODE_EXPORTER_SVC.stop_cmd(**node_exporter_args))

        # stop cadvisor
        cadvisor_args = {
            "container_bin": self.DEFAULT_CONTAINER_BIN,
            "container_name": CadvisorService.DEFAULT_CONTAINER_NAME,
            "remotes": self.cadvisor_hosts,
            "force": True,
        }
        cmds.extend(self.CADVISOR_SVC.stop_cmd(**cadvisor_args))

        # stop grafana
        grafana_args = {
            "container_bin": self.DEFAULT_CONTAINER_BIN,
            "container_name": GrafanaService.DEFAULT_CONTAINER_NAME,
            "remotes": self.grafana_hosts,
            "force": True,
        }
        cmds.extend(self.GRAFANA_SVC.stop_cmd(**grafana_args))

        return cmds

    def remove_cmd(
        self, config: str, user: str, key: str, **kargs
    ) -> List[str]:
        self.parse_config(config)

        global ssh_cmd
        ssh_cmd = f"ssh -i {key} {user}@"

        # stop all containers
        stop_cmds = self.stop_cmd(config, user, key, **kargs)
        # remove store persistent data
        store_args = {
            "container_bin": self.DEFAULT_CONTAINER_BIN,
            "container_name": HStoreService.DEFAULT_CONTAINER_NAME,
            "remotes": self.hstore_hosts,
            "persistent_dir": self.hstore_persistent_dir,
            "shards": self.shards,
        }
        remove_hstore_cmds = self.HSTORE_SVC.remove_cmd(
            # since we already removed the container
            **store_args,
            remove_container=False,
        )
        # remove zk persistent data
        zk_args = {
            "container_bin": self.DEFAULT_CONTAINER_BIN,
            "container_name": ZookeeperService.DEFAULT_CONTAINER_NAME,
            "remotes": self.zk_hosts,
            "persistent_dir": self.zk_persistent_dir,
        }
        remove_zk_cmds = self.ZK_SVC.remove_cmd(
            **zk_args, remove_container=False
        )

        return [*stop_cmds, *remove_hstore_cmds, *remove_zk_cmds]

    def print_help(self):
        return self.cmd.print_help()

    def pre_start(self, user, key):
        """
        pre-start will synchronize config files to all hosts
        """
        cmds = []
        # FIXME: store local config is always required because user should set zookeeper related field, which cannot
        #  be default
        cmds.extend(
            synchronize_configs(
                user,
                key,
                self.hstore_local_conf,
                self.hstore_remote_conf,
                self.hstore_hosts,
            )
        )
        cmds.extend(
            synchronize_configs(
                user,
                key,
                self.hserver_local_conf,
                self.hserver_remote_conf,
                self.hserver_hosts,
            )
        )
        cmds.extend(
            synchronize_configs(
                user,
                key,
                self.prometheus_local_conf,
                self.prometheus_remote_conf,
                self.prometheus_hosts,
            )
        )
        cmds.extend(
            synchronize_configs(
                user,
                key,
                self.grafana_local_conf,
                self.grafana_remote_conf,
                self.grafana_hosts,
            )
        )
        cmds.extend(
            synchronize_configs(
                user,
                key,
                self.grafana_local_provisioning_path,
                self.grafana_remote_provisioning_path,
                self.grafana_hosts,
            )
        )
        return cmds


# -----------------------------------------------------------------------------


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="HStream dev tools.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    s = Service(parser)
    s.register(ZookeeperService)
    s.register(HStoreAdminService)
    s.register(HStoreService)
    s.register(HServerService)
    s.register(PrometheusService)
    s.register(NodeExporterService)
    s.register(CadvisorService)
    s.register(GrafanaService)
    s.register(SimpleService)
    s.run()
